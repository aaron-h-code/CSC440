#include <algorithm>
#include <iostream>
#include <cmath>

using namespace std;

#include "tree.hpp"
#include "database.hpp"

FSET FP_growth(const tree& fptree){
	if(fptree.is_empty()){
		return {};
	}

	if(fptree.is_single_path()){
		FSET single_res;
		tree_node* cur_ptr = fptree.root->children.front();
		while(cur_ptr != nullptr){
			const ITEM cur_ptr_item = cur_ptr->item;
			const int cur_ptr_freq = cur_ptr->freq;
			pair<ITEMSET, int> p{{cur_ptr_item}, cur_ptr_freq};
			single_res.insert(p);

			for(const pair<ITEMSET, int> r : single_res){
				pair<ITEMSET, int> np{r};
				np.first.insert(cur_ptr_item);
				if(np.second > cur_ptr_freq){
					np.second = cur_ptr_freq;
				}
				single_res.insert(np);
			}

			if(cur_ptr->children.size() == 1){
				cur_ptr = cur_ptr->children.front();
			}else if(cur_ptr->children.size() == 0){
				cur_ptr = nullptr;
			}else{
				exit(-1);
			}
		}

		return single_res;
	}else{
		FSET multi_res;
		for(const pair<ITEM, tree_node*>& e : fptree.header_table){
			const ITEM& cur_item = e.first;

			// Build conditional fptree
			CPBASE cond_p_base;
			tree_node* t_start_ptr = e.second;
			while(t_start_ptr != nullptr){
				const int t_start_freq = t_start_ptr->freq;
				tree_node* cur_ptr = t_start_ptr->parent;
				if(cur_ptr->parent != nullptr){
					pair<ITEMSET, int> ps{{}, t_start_freq};
					while(cur_ptr->parent != nullptr){
						ps.first.insert(cur_ptr->item);
						cur_ptr = cur_ptr->parent;
					}
					cond_p_base.push_back(ps);
				} 
				t_start_ptr = t_start_ptr->next_node;
			}

			// Generate transactions through the conditional pattern base
			DATABASE cond_db;
			for(const pair<ITEMSET, int>& ps: cond_p_base){
				const ITEMSET& cond_items = ps.first;
				const int cond_freq = ps.second;
				TRANS trans = cond_items;
				// Add trans for cond_freq times
				for(int i = 0; i < cond_freq; i++){
					cond_db.push_back(trans);
				}
			}

			// Build conditional fp_tree
			tree cond_fptree(fptree.abs_min_sup);
			// Order items based on their frequency (not less the minimal support) in decreasing order
			cond_fptree.build_freq_of_item(cond_db);
			// Build the tree: add leaves and construct the header_table
			cond_fptree.build_tree(cond_db);

			FSET cond_res = FP_growth(cond_fptree);
			FSET cur_res;
			int cur_freq = 0;
			tree_node* ptr = e.second;
			while(ptr != nullptr){
				cur_freq += ptr->freq;
				ptr = ptr->next_node;
			}
			pair<ITEMSET, int> p{{cur_item}, cur_freq};
			cur_res.insert(p);

			for(const pair<ITEMSET, int>& cr : cond_res){
				pair<ITEMSET, int> np{cr};
				np.first.insert(cur_item);
				np.second = cr.second;

				cur_res.insert({np});
			}
			multi_res.insert(cur_res.cbegin(), cur_res.cend());
		}

		return multi_res;
	}
}

FSET fp_growth_alg(DATABASE& db, float rel_min_sup){

	int abs_min_sup = ceil(db.size() * rel_min_sup);

	// Initialize a tree, without leaves
	tree fptree(abs_min_sup);

	// Order items based on their frequency (not less the minimal support) in decreasing order
	fptree.build_freq_of_item(db);

	// Build the tree: add leaves and construct the header_table
	fptree.build_tree(db);

	// Run FP_growth recursively
	FSET res = FP_growth(fptree);

	return res;
}

// Display frequent itemsets generated by FP-growth
void display_fset(FSET& fset){
	for(const pair<ITEMSET, int>& p : fset){
		cout << "{ ";
		for(const ITEM& it : p.first){
			cout << it << " ";
		}
		cout << "} : " << p.second << endl;
	}
}